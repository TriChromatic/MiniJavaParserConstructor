import java.util.ArrayList;
import java.util.List;

/**
 * Delimiter parser part of the parser generator removes brackets and takes things like a-z and turns to into alphabet.
 * Created by TriChromatic aka Dylan Eicher on 11/17/14.
 */
public class DelimiterParser {
    private final List<Token> TOKENS;

    /**
     * Parses and modifys input delims
     *
     * @param delims delimiters to be parsed
     */
    DelimiterParser( String delims ) {

        /*replaces certain abbreviations and non-enterable chars*/
        String delimiters = delims.replace( "a-z", "abcdefghijklmnopqrstuvwxyz" );
        delimiters = delimiters.replace( "A-Z", "abcdefghijklmnopqrstuvwxyz".toUpperCase() );
        delimiters = delimiters.replace( "*S", "\u0020" );
        delimiters = delimiters.replace( "*N", "\u2424" );

        String[] tempTokens = delimiters.split( "((?<=[\\[\\]])|(?=[\\[\\]]))" ); //Split on brackets

        /*VERY important generate parsetree step.*/
        TOKENS = generateParseTree( removeNull( tempTokens ) );
    }

    /**
     * @return Tokens
     */
    public List<Token> getTokens() {
        return new ArrayList<>( TOKENS );
    }

    /**
     * @param tokens Array of tokens from split
     * @return A new list of tokens with null tokens removed
     */
    private List<String> removeNull( String[] tokens ) {
        ArrayList<String> list = new ArrayList<>();
        for ( String s : tokens ) {
            if ( s != null && s.length() > 0 ) {
                list.add( s );
            }
        }
        return list;
    }

    /**
     * Generates parse tree like list of tokens. Generated by looking at flow and syntax sorting.
     *
     * @param tokens Tokens
     * @return Parse tree
     */
    private List<Token> generateParseTree( List<String> tokens ) {
        boolean open = false;
        List<Token> sortedParse = new ArrayList<>();

        /*Flow open and close delims*/
        final String FLOW_OPEN = Character.toString( Syntax.FLOW_O.getC() );
        final String FLOW_CLOSE = Character.toString( Syntax.FLOW_C.getC() );

        /*Loops through the tokens and creates tokens based on whether they are syntax or not*/
        for ( String token : tokens ) {
            if ( token.equals( FLOW_OPEN ) ) {
                open = true;

            } else if ( token.equals( FLOW_CLOSE ) ) {
                open = false;

            } else {
                if ( open ) {
                    sortedParse.add( new Token( token, true ) );
                } else {

                    /*If the flow is closed, we loop through each token one char at a time. If it is not registered
                    * syntax, it is disregarded and a warning is issued.*/
                    for ( int i = 0; i < token.length(); i++ ) {
                        String convert = Character.toString( token.charAt( i ) );
                        if ( Syntax.isSyntax( convert ) ) {
                            sortedParse.add( new Token( convert, false ) );
                        } else {
                            System.out.println( String.format( StoredText.TOKEN_WARNING.txt(), convert ) );
                        }
                    }
                }

            }
        }

        return sortedParse;
    }
}
